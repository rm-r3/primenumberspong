<!--
  PONG-RM-v003.1 — Prime Numbers Pong
  Creative coding / digital art game

  Author: Rene Mathis
  Versions:
    v003.1  (2026-01-09)
    v003.0  (2025)
    v001.0  (2023)

  Description:
  Experimental 4-player Pong game combining prime number logic,
  generative visuals, and real-time interaction.

  Technologies:
  p5.js, p5.sound.js, JavaScript (ES6+), HTML5 Canvas

  License:
  Source code licensed under the MIT License.
  See LICENSE file for full text.

  © Rene Mathis
-->
<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon_pong_32x32.svg">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon_pong_32x32.png">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <!-- PWA -->
    <link rel="manifest" href="manifest.webmanifest">
    <meta name="theme-color" content="#000000">

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FKKELVR3X2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-FKKELVR3X2');
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRIME-PONG-003</title>

    <link rel="preconnect" href="https://fonts.bunny.net">
    <link href="https://fonts.bunny.net/css?family=press-start-2p:400" rel="stylesheet" />

    <style>
      @font-face {
        font-family: 'Rubik80sFade';
        src: url('fonts/Rubik80sFade-Regular.ttf') format('truetype');
      }
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        background-color: #000000;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        padding: 0;
        margin: 0;
        font-family: 'Rubik80sFade', 'Press Start 2P', monospace;
        overflow: hidden;
        box-sizing: border-box;
      }
      
      #mainWrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        height: 100vh;
        padding: 10px 0 60px 0;
        box-sizing: border-box;
      }
      
      #primeNumbersTicker {
        width: 80vw;
        max-width: 1200px;
        height: 20px;
        overflow: hidden;
        position: relative;
        margin-top: 10px;
        margin-bottom: 8px;
        text-align: right;
        padding-right: 25px;
        padding-left: 25px;
      }
      
      #primeNumbersTicker::before {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        width: 50px;
        height: 100%;
        background: linear-gradient(to right, #000000 0%, transparent 100%);
        z-index: 10;
        pointer-events: none;
      }
      
      #primeNumbersScroll {
        display: inline-block;
        font-family: 'Press Start 2P', monospace;
        font-size: clamp(8px, 1vw, 12px);
        color: #ffffff;
        white-space: nowrap;
        transition: transform 0.3s ease-out;
        position: relative;
        transform: translateX(0);
      }
      
      #primeNumbersTicker:hover #primeNumbersScroll {
        cursor: pointer;
      }
      
      #topContainers {
        width: 80vw;
        max-width: 1200px;
        display: flex;
        gap: 20px;
        margin-bottom: 14px;
      }
      
      .top-container {
        background-color: #000000;
        border-radius: 25px;
        padding: 10px 18px;
        text-align: center;
        transition: all 0.3s;
      }
      
      #scoreContainer {
        flex: 1;
        border: 1px solid #00ffff;
        box-shadow: 0 0 0 3px #000000, 0 0 0 6px #00ffff;
      }
      
      #primeContainer {
        flex: 0 0 auto;
        min-width: 220px;
        border: 1px solid #808080;
        box-shadow: 0 0 0 3px #000000, 0 0 0 6px #808080;
      }
      
      #primeContainer.prime-yes {
        border-color: #ffff00;
        box-shadow: 0 0 0 3px #000000, 0 0 0 6px #ffff00;
      }
      
      #shotsContainer {
        flex: 0 0 auto;
        min-width: 150px;
        border: 1px solid #ff69b4;
        box-shadow: 0 0 0 3px #000000, 0 0 0 6px #ff69b4;
      }
      
      .container-label {
        font-family: 'Press Start 2P', monospace;
        font-size: clamp(8px, 1vw, 12px);
        color: #ffffff;
        margin-bottom: 5px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      
      .container-value {
        font-family: 'Rubik80sFade', monospace;
        font-size: clamp(24px, 4vw, 48px);
        letter-spacing: 0.1em;
      }
      
      #scoreText {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 0.3em;
      }
      
      .score-ufo {
        color: #dd00dd;  /* Purple/Magenta for UFO player (matches random purple) */
        animation: ufo-blink 0.12s infinite;
      }
      
      @keyframes ufo-blink {
        0% { color: rgb(193, 0, 81); }
        25% { color: rgb(244, 0, 132); }
        50% { color: rgb(78, 0, 94); }
        75% { color: rgb(126, 0, 157); }
        100% { color: rgb(193, 0, 81); }
      }
      
      .score-top {
        color: #1adecc;  /* Cyan/Green-blue for top player OBEN (matches fill(44, 190, 222)) */
      }
      
      .score-left {
        color: #ff0055;  /* Pinkish red for left player (matches fill(200, 0, 60)) */
      }
      
      .score-right {
        color: #66cce6;  /* Light blue for right player (matches fill(130, 190, 200)) */
      }
      
      .score-separator {
        color: #666666;  /* Gray separators */
      }
      
      #primeValue {
        color: #808080;
        transition: color 0.3s;
      }
      
      #primeContainer.prime-yes #primeValue {
        color: #ffff00;
      }
      
      #shotsValue {
        color: #ff69b4;
      }
      
      @keyframes blink-white {
        0%, 100% { color: #ff69b4; }
        50% { color: #ffffff; }
      }
      
      .blink-animation {
        animation: blink-white 0.2s 5;
      }
      
      #gameContainer {
        width: 80vw;
        max-width: 1200px;
        aspect-ratio: 4 / 3;
        background-color: #000000;
        border: 1px solid #ff69b4;
        border-radius: 15px;
        position: relative;
        overflow: hidden;
        box-shadow: 
          0 0 0 2px #000000,
          0 0 0 5px #ff69b4;
      }
      
      canvas {
        display: block;
        width: 100% !important;
        height: 100% !important;
      }
      
      #startOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        cursor: pointer;
        z-index: 1000;
        transition: opacity 0.3s;
        gap: 0;
      }
      
      #startOverlay.hidden {
        opacity: 0;
        pointer-events: none;
      }
      
      #startLine1 {
        font-family: 'Rubik80sFade', monospace;
        color: #ffff00;  /* Yellow */
        font-size: clamp(28px, 7.7vw, 92px);  /* 92pt reference */
        text-align: center;
        letter-spacing: 0.05em;
        margin: 0;
        padding: 0;
      }
      
      #startLine2 {
        font-family: 'Rubik80sFade', monospace;
        color: #ff69b4;  /* Pink */
        font-size: clamp(80px, 22.75vw, 273px);  /* 273pt reference - HUGE! */
        text-align: center;
        letter-spacing: 0.05em;
        margin: 0;
        padding: 0;
        margin-top: clamp(-10px, -1vh, 0px);  /* Slight negative margin to bring closer */
        line-height: 0.9;
      }
      
      #startText {
        font-family: 'Rubik80sFade', 'Press Start 2P', monospace;
        color: #00ffff;
        font-size: clamp(20px, 4vw, 40px);  /* 40pt reference */
        text-align: center;
        animation: pulse 2s infinite;
        margin-top: clamp(10px, 2vh, 30px);
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
      
      #gameControls {
        width: 80vw;
        max-width: 1200px;
        display: flex;
        justify-content: space-between;
        gap: 40px;
        margin-top: 15px;
        padding-right: 25px;
        padding-left: 25px;
      }
      
      #counterDisplay {
        font-family: 'Press Start 2P', monospace;
        font-size: clamp(10px, 1.2vw, 14px);
        color: #ff69b4;  /* Pink by default */
        user-select: none;
      }
      
      #counterDisplay.prime {
        color: #ffff00;  /* Yellow when prime */
      }
      
      #aboutButton {
        font-family: 'Press Start 2P', monospace;
        font-size: clamp(10px, 1.2vw, 14px);
        color: rgb(35, 60, 220);  /* Custom blue */
        cursor: pointer;
        user-select: none;
        transition: opacity 0.3s;
      }
      
      #aboutButton:hover {
        opacity: 0.7;
      }
      
      #ufoPilotButton {
        font-family: 'Press Start 2P', monospace;
        font-size: clamp(10px, 1.2vw, 14px);
        color: #ff69b4;  /* Pink by default */
        cursor: pointer;
        user-select: none;
        transition: opacity 0.3s;
      }
      
      #ufoPilotButton.active {
        color: rgb(5, 200, 40);  /* Green when active */
      }
      
      #ufoPilotButton:hover {
        opacity: 0.7;
      }
      
      /* About Modal */
      #aboutModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }
      
      #aboutModal.show {
        display: flex;
      }
      
      #aboutContent {
        background: #1a1a2e;
        border: 3px solid rgb(35, 60, 220);
        border-radius: 15px;
        padding: 30px 40px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        font-family: 'Press Start 2P', monospace;
        color: #ffffff;
      }
      
      #aboutContent h2 {
        color: rgb(35, 60, 220);
        font-size: clamp(16px, 2vw, 20px);
        margin-bottom: 20px;
        text-align: center;
      }
      
      #aboutContent p {
        font-size: clamp(8px, 1vw, 11px);
        line-height: 1.8;
        margin-bottom: 15px;
      }
      
      #aboutContent a {
        color: #ff69b4;
        text-decoration: none;
        transition: opacity 0.3s;
      }
      
      #aboutContent a:hover {
        opacity: 0.7;
      }
      
      #aboutClose {
        display: block;
        margin: 20px auto 0;
        padding: 10px 20px;
        background: #ff69b4;
        color: #000;
        border: none;
        border-radius: 8px;
        font-family: 'Press Start 2P', monospace;
        font-size: clamp(9px, 1vw, 12px);
        cursor: pointer;
        transition: opacity 0.3s;
      }
      
      #aboutClose:hover {
        opacity: 0.8;
      }
      
      #controlButtons {
        display: flex;
        gap: 40px;
      }
      
      .control-button {
        font-family: 'Press Start 2P', monospace;
        font-size: clamp(10px, 1.2vw, 14px);
        cursor: pointer;
        user-select: none;
        transition: color 0.3s;
      }
      
      .control-button.active {
        color: #ff69b4;
      }
      
      .control-button.inactive {
        color: #ffffff;
      }
      
      .control-button:hover {
        opacity: 0.7;
      }
      
      #specialPrimeIndicator {
        width: 80vw;
        max-width: 1200px;
        text-align: left;
        margin-top: 15px;
        padding-left: 25px;
        font-family: 'Press Start 2P', monospace;
        font-size: clamp(10px, 1.2vw, 14px);
        color: #ffffff;
        min-height: 20px;
      }
      
      /* Responsive adjustments for narrow viewports */
      @media (max-width: 900px) {
        #topContainers {
          gap: 15px;
        }
        
        .top-container {
          padding: 8px 12px;
        }
        
        .container-label {
          font-size: clamp(7px, 1vw, 10px);
          margin-bottom: 3px;
        }
        
        .container-value {
          font-size: clamp(18px, 3vw, 36px);
        }
        
        #scoreContainer {
          min-width: 200px;
        }
        
        #primeContainer {
          min-width: 140px;
        }
        
        #shotsContainer {
          min-width: 90px;
        }
      }
      
      /* Responsive adjustments for very narrow viewports */
      @media (max-width: 600px) {
        #topContainers {
          gap: 10px;
        }
        
        .top-container {
          padding: 6px 10px;
        }
        
        .container-label {
          font-size: 8px;
          margin-bottom: 2px;
        }
        
        .container-value {
          font-size: clamp(16px, 4vw, 28px);
        }
        
        #scoreText {
          gap: 0.2em;
        }
        
        #primeNumbersTicker {
          height: 18px;
          margin-top: 8px;
          margin-bottom: 6px;
        }
        
        #primeNumbersScroll {
          font-size: 9px;
        }
      }
      
      /* Responsive adjustments for wide but short viewports */
      @media (min-aspect-ratio: 16/10) and (max-height: 800px) {
        #mainWrapper {
          padding: 5px 0 60px 0;
        }
        
        #primeNumbersTicker {
          height: 18px;
          margin-top: 5px;
          margin-bottom: 5px;
        }
        
        .top-container {
          padding: 7px 15px;
        }
        
        .container-label {
          font-size: 10px;
          margin-bottom: 3px;
        }
        
        .container-value {
          font-size: clamp(20px, 3.5vw, 40px);
        }
        
        #topContainers {
          margin-bottom: 8px;
          gap: 15px;
        }
      }
      
      /* Extra adjustments for very short viewports */
      @media (max-height: 700px) {
        #mainWrapper {
          padding: 3px 0 60px 0;
        }
        
        #primeNumbersTicker {
          height: 16px;
          margin-top: 3px;
          margin-bottom: 3px;
        }
        
        #primeNumbersScroll {
          font-size: 9px;
        }
        
        .top-container {
          padding: 5px 12px;
        }
        
        .container-label {
          font-size: 9px;
          margin-bottom: 2px;
        }
        
        .container-value {
          font-size: clamp(18px, 3vw, 32px);
        }
        
        #topContainers {
          gap: 12px;
          margin-bottom: 5px;
        }
      }
    </style>
  </head>
  <body>
    <div id="mainWrapper">
      <div id="primeNumbersTicker">
        <div id="primeNumbersScroll"></div>
      </div>
      
      <div id="topContainers">
      <div id="scoreContainer" class="top-container">
        <div id="scoreText" class="container-value">
          <span class="score-ufo">0</span>
          <span class="score-separator">-</span>
          <span class="score-top">0</span>
          <span class="score-separator">-</span>
          <span class="score-left">0</span>
          <span class="score-separator">-</span>
          <span class="score-right">0</span>
        </div>
        <div class="container-label" style="margin-top: 3px; margin-bottom: 0;">SCORE</div>
      </div>
      
      <div id="primeContainer" class="top-container">
        <div id="primeValue" class="container-value">0</div>
        <div class="container-label" style="margin-top: 3px; margin-bottom: 0;">
          <span>PRIMENUMBER: </span><span id="primeStatus">NO</span>
        </div>
      </div>
      
      <div id="shotsContainer" class="top-container">
        <div id="shotsValue" class="container-value">3</div>
        <div class="container-label" style="margin-top: 3px; margin-bottom: 0;">SHOTS</div>
      </div>
    </div>
    
    <div id="gameContainer">
      <div id="startOverlay">
        <div id="startLine1">PRIMENUMBERS</div>
        <div id="startLine2">PONG</div>
        <div id="startText">CLICK TO START</div>
      </div>
    </div>
    
    <div id="gameControls">
      <div id="leftControls">
        <div id="counterDisplay">0</div>
      </div>
      <div id="controlButtons">
        <div id="aboutButton">ABOUT</div>
        <div id="ufoPilotButton">UFOPILOT</div>
        <div id="soundControl" class="control-button active">SOUND ON</div>
        <div id="pauseControl" class="control-button active">PAUSE</div>
      </div>
    </div>
    
    <!-- About Modal -->
    <div id="aboutModal">
      <div id="aboutContent">
        <h2>PONG-RM-v000</h2>
        <p><strong>CONTROLS:</strong></p>
        <p>MOUSE: Move paddle<br>CLICK: Fire shot</p>
        
        <p><strong>MECHANICS:</strong></p>
        <p>Score primes to gain shots. Special primes unlock triple-shot! Obstacles spawn on prime seconds. Paddles get stronger on prime hits.</p>
        
        <p><strong>CREATED BY:</strong></p>
        <p>Rene Mathis</p>
        
        <p><strong>CONNECT:</strong></p>
        <p>
          <a href="https://www.linkedin.com/in/rene-mathis-conceptdesign" target="_blank">LinkedIn</a><br>
          <a href="https://mathis-conceptdesign-portfolio.com" target="_blank">Portfolio</a>
        </p>
        
        <p><strong>TECH:</strong></p>
        <p>p5.js | JavaScript | Prime Numbers</p>
        
        <button id="aboutClose">CLOSE</button>
      </div>
    </div>
    
    <div id="specialPrimeIndicator"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
    
    <script>
// ============ CLASSES.JS ============
class Dot {
    constructor (x, y, a, b, gameWidth, gameHeight) {
      this.position =  {x: x, y: y}
      this.velocity = {x: a, y: b}
      this.gameWidth = gameWidth
      this.gameHeight = gameHeight
    }
    updatePosition() {
      this.position.x += this.velocity.x
      this.position.y += this.velocity.y
    }
    checkCollision() {
      if (this.position.x <= 0 || this.position.x >= this.gameWidth) {
        this.velocity.x = this.velocity.x * -1
      }
      if (this.position.y <= 0 || this.position.y >= this.gameHeight) {
        this.velocity.y = this.velocity.y * -1
      }
    }
  }
  
  class DotComposition {
    constructor (x, y, velocity, dotSize, color) {
      this.dots = []
      this.dotSize = dotSize
      this.velocity = velocity
      this.color = color
      this.origin = {x: x, y: y}
    }
    initialize() {
      if (this.dots.length === 0) {
        let gw = width;
        let gh = height;
        
        this.dots.push(new Dot(this.origin.x, this.origin.y, 0, -this.velocity, gw, gh))
        this.dots.push(new Dot(this.origin.x, this.origin.y, this.velocity, 0, gw, gh))
        this.dots.push(new Dot(this.origin.x, this.origin.y, 0, this.velocity, gw, gh))
        this.dots.push(new Dot(this.origin.x, this.origin.y, -this.velocity, 0, gw, gh))
      }
    }
    update() {
      for (const dot of this.dots) {
        dot.gameWidth = width;
        dot.gameHeight = height;
        dot.updatePosition()
        dot.checkCollision()
      }
    }
    display() {
      for (const dot of this.dots) {
        push()
        fill(this.color.r, this.color.g, this.color.b)
        ellipse(dot.position.x, dot.position.y, this.dotSize, this.dotSize)
        pop()
      }
    }
  }

// ============ PONG_TEST7.JS ============
let bullets = [];
let scoreTextElement = document.querySelector("#scoreText");

var xBall = 400;
var yBall = 300;
var diameter = 75;
var xSpeed = 6;
var ySpeed = -6;
var baseSpeed = 6;  // Store initial speed
var speedMultiplier = 1;  // Speed multiplier that increases over time
var speedIncreaseRate = 0.0005;  // How fast the ball speeds up per frame

let gameWidth = 1200;
let gameHeight = 900;

function randomizeBallDirection() {
  xSpeed = (Math.random() < 0.5 ? -baseSpeed : baseSpeed);
  ySpeed = (Math.random() < 0.5 ? -baseSpeed : baseSpeed);
  speedMultiplier = 1;  // Reset speed multiplier when ball resets
  
  // Play startup sound when ball resets to center
  if (audioUnlocked && window.soundEnabled && sounds.start) {
    sounds.start.cloneNode().play().catch(err => {});
  }
}

var paddleWidth1 = 120;
var paddleHeight1 = 36;
var paddleWidth11 = 120;
var paddleHeight11 = 30;
var paddleWidth22 = 30;
var paddleHeight22 = 58;
var paddleWidth44 = 30;
var paddleHeight44 = 58;

let x1, y1, x2, y2, x3, y3, x4, y4;
let x1b, y1b, x2b, y2b, x3b, y3b, x4b, y4b;
let x1c, y1c, x2c, y2c, x3c, y3c, x4c, y4c;
let x10, y10, x20, y20, x30, y30, x40, y40;
let x100, y100, x200, y200, x300, y300, x400, y400;
let x1000, y1000, x2000, y2000, x3000, y3000, x4000, y4000;
let x10000, y10000, x20000, y20000, x30000, y30000, x40000, y40000;

var score = [0, 0, 0, 0];

let dotCompositions = []
let rubikFont;  // Variable to store the font
let audioUnlocked = false;  // Track if audio is unlocked
window.gameStarted = false;  // Track if game has started - make explicitly global
window.gamePaused = false;  // Track if game is paused - make explicitly global
window.soundEnabled = true;  // Track if sound is enabled - make explicitly global
let ballBlinking = false;  // Track if ball is blinking
let blinkStartTime = 0;  // When blink started
let blinkCount = 0;  // Current blink number
let specialPrimeActive = false;  // Track if current prime is special

// Paddle strength system
let paddleHitCounts = {
  top: 0,
  left: 0,
  right: 0,
  ufo: 0
};

let paddleStrengthLevels = [1.0, 1.02, 1.05, 1.1];  // Strength progression on prime hits
let paddleCurrentStrength = {
  top: 0,    // Index in paddleStrengthLevels array
  left: 0,
  right: 0,
  ufo: 0
};

// Rotating obstacles system
let obstacles = [];
let lastObstacleCheck = 0;  // Track last time we checked for obstacle spawn

// UFO Autopilot system
let autoPilotActive = false;
let autoPilotTargetX = 0;
let autoPilotShootTimer = 0;

let sounds = {
  left: [],   // fx_1_01.mp3, fx_1_02.mp3
  top: [],    // fx_1_03.mp3, fx_1_04.mp3
  right: [],  // fx_1_05.mp3, fx_1_06.mp3
  ufo: [],    // fx_1_07.mp3, fx_1_08.mp3
  start: null, // fx_1_09.mp3 - ball start sound
  lauflichter: [], // fx_1_11.mp3, fx_1_15.mp3, fx_1_18.mp3 - LAUFLICHTER collision sounds
  shoot: null, // fx_1_19.mp3 - shooting sound
  blink: null  // fx_1_20.mp3 - ball blink sound
};

// === PRIME NUMBER & SHOT SYSTEM ===
let shotBalls = [];  // Array to store active shot balls
let shotsAvailable = 3;  // Player starts with 3 shots
let lastPrimeCheck = 0;  // Track last checked prime number
let frozenPaddles = {
  top: 0,    // Timestamp when paddle was frozen
  left: 0,
  right: 0
};
let frozenPositions = {
  top: 0,    // Frozen X position for top paddle
  left: 0,   // Frozen Y position for left paddle
  right: 0   // Frozen Y position for right paddle
};
let unlockedPrimes = [];  // Array to store all unlocked prime numbers

function preload() {
  // Font loading disabled - CSS handles fonts instead
  
  // Load sounds using native HTML5 Audio (not p5.sound)
  sounds.left[0] = new Audio('sound/fx_1_01.mp3');
  sounds.left[1] = new Audio('sound/fx_1_02.mp3');
  sounds.top[0] = new Audio('sound/fx_1_03.mp3');
  sounds.top[1] = new Audio('sound/fx_1_04.mp3');
  sounds.right[0] = new Audio('sound/fx_1_05.mp3');
  sounds.right[1] = new Audio('sound/fx_1_06.mp3');
  sounds.ufo[0] = new Audio('sound/fx_1_07.mp3');
  sounds.ufo[1] = new Audio('sound/fx_1_08.mp3');
  sounds.start = new Audio('sound/fx_1_09.mp3');
  sounds.lauflichter[0] = new Audio('sound/fx_1_11.mp3');
  sounds.lauflichter[1] = new Audio('sound/fx_1_15.mp3');
  sounds.lauflichter[2] = new Audio('sound/fx_1_18.mp3');
  sounds.shoot = new Audio('sound/fx_1_19.mp3');
  sounds.blink = new Audio('sound/fx_1_20.mp3');
  
  // Set volume for all sounds
  Object.values(sounds).forEach(item => {
    if (Array.isArray(item)) {
      item.forEach(sound => {
        sound.volume = 0.5;
      });
    } else if (item) {
      item.volume = 0.5;
    }
  });
}

// === PRIME NUMBER DETECTION ===
function isPrime(num) {
  if (num < 2) return false;
  if (num === 2) return true;
  if (num % 2 === 0) return false;
  for (let i = 3; i <= Math.sqrt(num); i += 2) {
    if (num % i === 0) return false;
  }
  return true;
}

// Check if number is a Fermat prime (2^(2^n) + 1)
function isFermatPrime(num) {
  // Known Fermat primes: 3, 5, 17, 257, 65537
  const fermatPrimes = [3, 5, 17, 257, 65537];
  return fermatPrimes.includes(num);
}

// Check if number is a Mersenne prime (2^p - 1)
function isMersennePrime(num) {
  // Check if num + 1 is a power of 2
  let n = num + 1;
  return n > 0 && (n & (n - 1)) === 0 && isPrime(num);
}

// Check if number is palindromic
function isPalindromicPrime(num) {
  let str = num.toString();
  let reversed = str.split('').reverse().join('');
  return str === reversed && isPrime(num);
}

// Check if number is a twin prime (prime with prime ±2)
function isTwinPrime(num) {
  return isPrime(num) && (isPrime(num - 2) || isPrime(num + 2));
}

// Check if number is a Sophie Germain prime (2p+1 is also prime)
function isSophieGermainPrime(num) {
  return isPrime(num) && isPrime(2 * num + 1);
}

// Get special prime type description
function getSpecialPrimeType(num) {
  if (!isPrime(num)) return null;
  
  let types = [];
  
  if (isFermatPrime(num)) {
    types.push("FERMAT PRIME");
  }
  if (isMersennePrime(num)) {
    types.push("MERSENNE PRIME");
  }
  if (isPalindromicPrime(num)) {
    types.push("PALINDROMIC PRIME");
  }
  if (isTwinPrime(num)) {
    types.push("TWIN PRIME");
  }
  if (isSophieGermainPrime(num)) {
    types.push("SOPHIE GERMAIN PRIME");
  }
  
  return types.length > 0 ? types.join(" / ") : null;
}

// Check if number is prime and in a "20s range" (23, 29, 43, 47, 67, 83, 89, 103, 107, etc.)
function isPrimeIn20sRange(num) {
  if (!isPrime(num)) return false;
  
  // Check if last digit is in 20s pattern (3, 7, or 9 for most 20s primes)
  // 20s primes: 23, 29 (in 20-29)
  // 40s primes: 41, 43, 47 (in 40-49)
  // 60s primes: 61, 67 (in 60-69)
  // 80s primes: 83, 89 (in 80-89)
  // Pattern: primes in decades ending in 0-9
  let digit = num % 10;
  let decade = Math.floor(num / 10) % 10;
  
  // Looking for primes in 20s, 40s, 60s, 80s, 100s, etc. (even tens digit)
  return decade % 2 === 0 && num >= 20;
}

function getLeaderScore() {
  return Math.max(score[0], score[1], score[2], score[3]);
}

function checkPrimeAndUpdateShots() {
  let leaderScore = getLeaderScore();
  
  // Update prime display
  document.getElementById('primeValue').textContent = leaderScore;
  
  let primeContainer = document.getElementById('primeContainer');
  let primeStatus = document.getElementById('primeStatus');
  let specialIndicator = document.getElementById('specialPrimeIndicator');
  
  if (isPrime(leaderScore)) {
    primeContainer.classList.add('prime-yes');
    primeStatus.textContent = 'YES';
    
    // Check for special prime types
    let specialType = getSpecialPrimeType(leaderScore);
    if (specialType) {
      specialIndicator.textContent = leaderScore + ": " + specialType;
      specialPrimeActive = true;  // Enable triple shot
    } else {
      specialIndicator.textContent = "";
      specialPrimeActive = false;  // Disable triple shot
    }
    
    // If this is a NEW prime (score increased), add a shot
    if (leaderScore > lastPrimeCheck) {
      lastPrimeCheck = leaderScore;
      shotsAvailable++;
      
      // Add to unlocked primes list if not already there
      if (!unlockedPrimes.includes(leaderScore)) {
        unlockedPrimes.push(leaderScore);
        unlockedPrimes.sort((a, b) => a - b);  // Keep sorted
        updatePrimesTicker();
      }
      
      // Update display with blink animation
      let shotsValue = document.getElementById('shotsValue');
      shotsValue.textContent = shotsAvailable;
      shotsValue.classList.add('blink-animation');
      setTimeout(() => shotsValue.classList.remove('blink-animation'), 1000);
    }
  } else {
    primeContainer.classList.remove('prime-yes');
    primeStatus.textContent = 'NO';
    specialIndicator.textContent = "";
    specialPrimeActive = false;  // Disable triple shot
  }
}

function updatePrimesTicker() {
  let ticker = document.getElementById('primeNumbersScroll');
  // Create string with spaces between numbers (no repeating)
  let primeString = unlockedPrimes.join('  ');
  ticker.textContent = primeString;
  // Numbers naturally align right due to parent text-align: right
}

// Add hover scrolling for prime numbers ticker
function setupPrimeTickerScroll() {
  let ticker = document.getElementById('primeNumbersTicker');
  let scroll = document.getElementById('primeNumbersScroll');
  
  ticker.addEventListener('mousemove', function(e) {
    let rect = ticker.getBoundingClientRect();
    let scrollWidth = scroll.offsetWidth;
    let containerWidth = ticker.offsetWidth;
    
    // Only scroll if content is wider than container
    if (scrollWidth > containerWidth) {
      let mouseX = e.clientX - rect.left;
      let containerMiddle = containerWidth / 2;
      
      // Calculate scroll position based on mouse position
      // Left side = scroll left to show older primes
      // Right side = scroll right to show newer primes
      let scrollRatio = (mouseX / containerWidth);
      let maxScroll = scrollWidth - containerWidth + 50; // 50px extra for padding
      let scrollAmount = -scrollRatio * maxScroll;
      
      scroll.style.transform = `translateX(${scrollAmount}px)`;
    }
  });
  
  ticker.addEventListener('mouseleave', function() {
    // Return to right-aligned position (showing newest primes)
    scroll.style.transform = 'translateX(0)';
  });
}

// Setup game controls (sound and pause)
function setupGameControls() {
  let soundControl = document.getElementById('soundControl');
  let pauseControl = document.getElementById('pauseControl');
  let aboutButton = document.getElementById('aboutButton');
  let ufoPilotButton = document.getElementById('ufoPilotButton');
  let aboutModal = document.getElementById('aboutModal');
  let aboutClose = document.getElementById('aboutClose');
  
  // Sound toggle
  soundControl.addEventListener('click', function() {
    window.soundEnabled = !window.soundEnabled;
    if (window.soundEnabled) {
      soundControl.textContent = 'SOUND ON';
      soundControl.classList.remove('inactive');
      soundControl.classList.add('active');
    } else {
      soundControl.textContent = 'SOUND OFF';
      soundControl.classList.remove('active');
      soundControl.classList.add('inactive');
    }
  });
  
  // Pause toggle
  pauseControl.addEventListener('click', function() {
    if (!window.gameStarted) return; // Can't pause before game starts
    
    window.gamePaused = !window.gamePaused;
    if (window.gamePaused) {
      noLoop(); // Pause p5.js draw loop
      pauseControl.classList.remove('active');
      pauseControl.classList.add('inactive');
    } else {
      loop(); // Resume p5.js draw loop
      pauseControl.classList.remove('inactive');
      pauseControl.classList.add('active');
    }
  });
  
  // UFO Autopilot toggle
  ufoPilotButton.addEventListener('click', function() {
    autoPilotActive = !autoPilotActive;
    if (autoPilotActive) {
      ufoPilotButton.classList.add('active');
    } else {
      ufoPilotButton.classList.remove('active');
    }
  });
  
  // About modal
  aboutButton.addEventListener('click', function() {
    aboutModal.classList.add('show');
  });
  
  aboutClose.addEventListener('click', function() {
    aboutModal.classList.remove('show');
  });
  
  // Close modal on background click
  aboutModal.addEventListener('click', function(e) {
    if (e.target === aboutModal) {
      aboutModal.classList.remove('show');
    }
  });
}

// Call setup after page loads
if (typeof window !== 'undefined') {
  window.addEventListener('load', function() {
    setupPrimeTickerScroll();
    setupGameControls();
  });
}

// Helper function to play random sound from a category
function playRandomSound(category) {
  if (!audioUnlocked) return;  // Don't play until user interacts
  if (!window.soundEnabled) return;  // Don't play if sound is disabled
  
  if (sounds[category] && sounds[category].length > 0) {
    let randomIndex = Math.floor(Math.random() * sounds[category].length);
    let sound = sounds[category][randomIndex];
    if (sound) {
      // Clone the audio to allow overlapping sounds
      let clone = sound.cloneNode();
      // Boost volume for top sounds if they're too quiet
      clone.volume = (category === 'top') ? 0.8 : 0.5;
      clone.play().catch(err => {
        // Silently handle play errors
      });
    }
  }
}

// === SHOT BALL CLASS ===
// ============ OBSTACLE CLASS ============
class Obstacle {
  constructor(x, y, side) {
    this.x = x;
    this.y = y;
    this.width = 35;
    this.height = 35;
    this.side = side;  // 'left' or 'right'
    this.rotation = 0;
    this.rotationSpeed = side === 'left' ? 0.02 : -0.02;  // Clockwise left, counter-clockwise right
    this.createdAt = millis();
    this.lifetime = 5000;  // 5 seconds
  }
  
  update() {
    // Rotate
    this.rotation += this.rotationSpeed;
    
    // Check if expired
    if (millis() - this.createdAt > this.lifetime) {
      return false;  // Signal to remove
    }
    return true;
  }
  
  display() {
    push();
    translate(this.x, this.y);
    rotate(this.rotation);
    
    // Fast blinking effect - more pronounced
    let blinkCycle = (millis() * 0.008) % 1.0;  // Faster blinking
    let alpha = blinkCycle < 0.5 ? 255 : 80;  // Stronger blink: full opacity to very dim
    
    // Draw rounded rectangle with pink outline
    noFill();
    stroke(255, 105, 180, alpha);  // Pink with fast blinking alpha
    strokeWeight(2);
    rectMode(CENTER);
    rect(0, 0, this.width, this.height, 8);  // 8px border radius
    
    pop();
  }
  
  checkBallCollision(ballX, ballY, ballRadius) {
    // Simple AABB collision for now (can be refined)
    // Get obstacle bounds
    let halfW = this.width / 2;
    let halfH = this.height / 2;
    
    // Find closest point on rectangle to ball center
    let closestX = constrain(ballX, this.x - halfW, this.x + halfW);
    let closestY = constrain(ballY, this.y - halfH, this.y + halfH);
    
    // Calculate distance
    let distX = ballX - closestX;
    let distY = ballY - closestY;
    let distance = sqrt(distX * distX + distY * distY);
    
    return distance < ballRadius;
  }
  
  checkShotBallCollision(shot) {
    // Check collision with shot ball
    let halfW = this.width / 2;
    let halfH = this.height / 2;
    
    // Find closest point on rectangle to shot ball center
    let closestX = constrain(shot.x, this.x - halfW, this.x + halfW);
    let closestY = constrain(shot.y, this.y - halfH, this.y + halfH);
    
    // Calculate distance
    let distX = shot.x - closestX;
    let distY = shot.y - closestY;
    let distance = sqrt(distX * distX + distY * distY);
    
    if (distance < shot.radius) {
      // Bounce shot ball off obstacle
      let angle = atan2(shot.y - this.y, shot.x - this.x);
      let speed = sqrt(shot.xSpeed * shot.xSpeed + shot.ySpeed * shot.ySpeed);
      shot.xSpeed = cos(angle) * speed;
      shot.ySpeed = sin(angle) * speed;
      return true;
    }
    return false;
  }
}

// ============ SHOTBALL CLASS ============
class ShotBall {
  constructor(x, y, xSpeed = 0, ySpeed = -15) {
    this.x = x;
    this.y = y;
    this.xSpeed = xSpeed;
    this.ySpeed = ySpeed;
    this.radius = 6;  // Smaller than game ball
    this.createdAt = millis();
    this.lifetime = 8000;  // 8 seconds
  }
  
  update() {
    // Check if expired
    if (millis() - this.createdAt > this.lifetime) {
      return false;  // Signal to remove
    }
    
    // Move
    this.x += this.xSpeed;
    this.y += this.ySpeed;
    
    // Wall bounces
    if (this.x < 0 || this.x > gameWidth) {
      this.xSpeed *= -1;
      this.x = constrain(this.x, 0, gameWidth);
    }
    if (this.y < 0 || this.y > gameHeight) {
      this.ySpeed *= -1;
      this.y = constrain(this.y, 0, gameHeight);
    }
    
    // Paddle collisions
    this.checkPaddleCollisions();
    
    // LAUFLICHTER collisions
    this.checkLauflichterCollisions();
    
    // Ball collision
    this.checkBallCollision();
    
    return true;  // Still alive
  }
  
  checkPaddleCollisions() {
    // UFO paddle (player paddle - just bounce, don't freeze)
    let ufoLeft = mouseX - 76;
    let ufoRight = mouseX + 76;
    let ufoTop = height - 98;
    let ufoBottom = height - 62;
    
    if (this.x >= ufoLeft && this.x <= ufoRight && 
        this.y + this.radius >= ufoTop && this.y <= ufoBottom) {
      this.ySpeed *= -1;
      this.y = ufoTop - this.radius;
    }
    
    // Top paddle - freeze if hit
    if (frozenPaddles.top < millis()) {
      let shotTopPaddleX = (frozenPaddles.top > millis()) ? frozenPositions.top : xBall;
      let shotTopPaddleDynamicWidth = Math.max(60, Math.abs(shotTopPaddleX - gameWidth/2) * 0.3 + 40);
      let shotTopPaddleLeft = shotTopPaddleX - shotTopPaddleDynamicWidth/2;
      let shotTopPaddleRight = shotTopPaddleX + shotTopPaddleDynamicWidth/2;
      let shotTopPaddleTop = 58 - paddleHeight11/2;
      let shotTopPaddleBottom = 58 + paddleHeight11/2;
      
      if (this.y - this.radius <= shotTopPaddleBottom && this.y >= shotTopPaddleTop && 
          this.x >= shotTopPaddleLeft && this.x <= shotTopPaddleRight) {
        this.ySpeed *= -1;
        this.y = shotTopPaddleBottom + this.radius;
        frozenPaddles.top = millis() + 5000;  // Freeze for 5 seconds
        frozenPositions.top = xBall;  // Store current X position
      }
    }
    
    // Left paddle - freeze if hit
    if (frozenPaddles.left < millis()) {
      let shotLeftPaddleYBall = (frozenPaddles.left > millis()) ? frozenPositions.left : yBall;
      let shotLeftPaddleX = paddleHeight22;
      let shotLeftPaddleY = shotLeftPaddleYBall / 0.9;
      let shotLeftPaddleWidth = paddleWidth22;
      let shotLeftPaddleHeight = Math.abs(shotLeftPaddleYBall - 222);
      
      let shotLeftPaddleLeft = shotLeftPaddleX - shotLeftPaddleWidth/2;
      let shotLeftPaddleRight = shotLeftPaddleX + shotLeftPaddleWidth/2;
      let shotLeftPaddleTop = shotLeftPaddleY - shotLeftPaddleHeight/2;
      let shotLeftPaddleBottom = shotLeftPaddleY + shotLeftPaddleHeight/2;
      
      if (this.x - this.radius <= shotLeftPaddleRight && this.x >= shotLeftPaddleLeft &&
          this.y >= shotLeftPaddleTop && this.y <= shotLeftPaddleBottom) {
        this.xSpeed *= -1;
        this.x = shotLeftPaddleRight + this.radius;
        frozenPaddles.left = millis() + 5000;  // Freeze for 5 seconds
        frozenPositions.left = yBall;  // Store current Y position (ball position)
      }
    }
    
    // Right paddle - freeze if hit
    if (frozenPaddles.right < millis()) {
      let shotRightPaddleYBall = (frozenPaddles.right > millis()) ? frozenPositions.right : yBall;
      let shotRightPaddleX = gameWidth - 88;
      let shotRightPaddleY = shotRightPaddleYBall / 0.9;
      let shotRightPaddleWidth = 30;
      let shotRightPaddleHeight = Math.abs(shotRightPaddleYBall - 222);
      
      let shotRightPaddleLeft = shotRightPaddleX - shotRightPaddleWidth/2;
      let shotRightPaddleRight = shotRightPaddleX + shotRightPaddleWidth/2;
      let shotRightPaddleTop = shotRightPaddleY - shotRightPaddleHeight/2;
      let shotRightPaddleBottom = shotRightPaddleY + shotRightPaddleHeight/2;
      
      if (this.x + this.radius >= shotRightPaddleLeft && this.x <= shotRightPaddleRight &&
          this.y >= shotRightPaddleTop && this.y <= shotRightPaddleBottom) {
        this.xSpeed *= -1;
        this.x = shotRightPaddleLeft - this.radius;
        frozenPaddles.right = millis() + 5000;  // Freeze for 5 seconds
        frozenPositions.right = yBall;  // Store current Y position (ball position)
      }
    }
  }
  
  checkLauflichterCollisions() {
    // Check collision with all moving LAUFLICHTER dots
    let dotRadius = 1.5;
    let shotRadius = this.radius;
    let collisionDistance = dotRadius + shotRadius;
    
    // Helper function to check single dot collision
    const checkSingleDot = (dotX, dotY) => {
      let dx = this.x - dotX;
      let dy = this.y - dotY;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < collisionDistance && distance > 0) {
        // Calculate bounce angle based on collision position
        let angle = Math.atan2(dy, dx);
        let speed = Math.sqrt(this.xSpeed * this.xSpeed + this.ySpeed * this.ySpeed);
        this.xSpeed = Math.cos(angle) * speed;
        this.ySpeed = Math.sin(angle) * speed;
        
        // Play random LAUFLICHTER collision sound
        playRandomSound('lauflichter');
        return true;
      }
      return false;
    };
    
    // Check all DotComposition dots (red and blue)
    for (const dotComposition of dotCompositions) {
      for (const dot of dotComposition.dots) {
        let dotCollisionRadius = dotComposition.dotSize / 2;
        let dotShotDistance = dotCollisionRadius + shotRadius;
        let dx = this.x - dot.position.x;
        let dy = this.y - dot.position.y;
        let distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < dotShotDistance && distance > 0) {
          // Calculate bounce angle based on collision position
          let angle = Math.atan2(dy, dx);
          let speed = Math.sqrt(this.xSpeed * this.xSpeed + this.ySpeed * this.ySpeed);
          this.xSpeed = Math.cos(angle) * speed;
          this.ySpeed = Math.sin(angle) * speed;
          
          // Play random LAUFLICHTER collision sound
          playRandomSound('lauflichter');
          break;
        }
      }
    }
    
    // Check all LAUFLICHTER groups (24 dots total)
    checkSingleDot(x1b, y1b) || checkSingleDot(x2b, y2b) || 
    checkSingleDot(x3b, y3b) || checkSingleDot(x4b, y4b) ||
    checkSingleDot(x1c, y1c) || checkSingleDot(x2c, y2c) || 
    checkSingleDot(x3c, y3c) || checkSingleDot(x4c, y4c) ||
    checkSingleDot(x10, y10) || checkSingleDot(x20, y20) || 
    checkSingleDot(x30, y30) || checkSingleDot(x40, y40) ||
    checkSingleDot(x100, y100) || checkSingleDot(x200, y200) || 
    checkSingleDot(x300, y300) || checkSingleDot(x400, y400) ||
    checkSingleDot(x1000, y1000) || checkSingleDot(x2000, y2000) || 
    checkSingleDot(x3000, y3000) || checkSingleDot(x4000, y4000) ||
    checkSingleDot(x10000, y10000) || checkSingleDot(x20000, y20000) || 
    checkSingleDot(x30000, y30000) || checkSingleDot(x40000, y40000);
  }
  
  checkBallCollision() {
    // Check collision with the main game ball (billiard-style)
    let dx = this.x - xBall;
    let dy = this.y - yBall;
    let distance = Math.sqrt(dx * dx + dy * dy);
    let minDistance = this.radius + 12; // shotRadius + ballRadius
    
    if (distance < minDistance && distance > 0) {
      // Calculate collision angle
      let angle = Math.atan2(dy, dx);
      
      // Calculate velocities along collision axis
      let shotSpeed = Math.sqrt(this.xSpeed * this.xSpeed + this.ySpeed * this.ySpeed);
      let ballSpeed = Math.sqrt(xSpeed * xSpeed + ySpeed * ySpeed);
      
      // Bounce shot ball away
      this.xSpeed = Math.cos(angle) * shotSpeed;
      this.ySpeed = Math.sin(angle) * shotSpeed;
      
      // Bounce game ball away (opposite direction)
      xSpeed = -Math.cos(angle) * ballSpeed;
      ySpeed = -Math.sin(angle) * ballSpeed;
      
      // Separate balls to prevent sticking
      let overlap = minDistance - distance;
      this.x += Math.cos(angle) * overlap / 2;
      this.y += Math.sin(angle) * overlap / 2;
      xBall -= Math.cos(angle) * overlap / 2;
      yBall -= Math.sin(angle) * overlap / 2;
    }
  }
  
  display() {
    push();
    fill(0, 226, 27);  // Bright green
    noStroke();
    ellipse(this.x, this.y, this.radius * 2, this.radius * 2);
    pop();
  }
}

function setup() {
  let container = document.getElementById('gameContainer');
  let w = container.offsetWidth;
  let h = container.offsetHeight;
  
  gameWidth = w;
  gameHeight = h;
  
  let canvas = createCanvas(gameWidth, gameHeight);
  canvas.parent('gameContainer');
  
  // Apply the Rubik 80s Fade font if it loaded
  if (rubikFont) {
    textFont(rubikFont);
  }
  
  // Setup start overlay click handler
  let startOverlay = document.getElementById('startOverlay');
  if (startOverlay) {
    startOverlay.addEventListener('click', function() {
      audioUnlocked = true;
      console.log('Audio unlocked!');
      
      // Play and pause all sounds to unlock audio
      Object.values(sounds).forEach(item => {
        if (Array.isArray(item)) {
          // Handle arrays (left, top, right, ufo)
          item.forEach(sound => {
            if (sound) {
              sound.play().then(() => {
                sound.pause();
                sound.currentTime = 0;
              }).catch(err => {});
            }
          });
        } else if (item) {
          // Handle single sound (start)
          item.play().then(() => {
            item.pause();
            item.currentTime = 0;
          }).catch(err => {});
        }
      });
      
      // Hide overlay
      startOverlay.classList.add('hidden');
      setTimeout(() => startOverlay.style.display = 'none', 300);
      
      // Mark game as started
      window.gameStarted = true;
      
      // Position ball at center
      xBall = gameWidth / 2;
      yBall = gameHeight / 2;
      
      // Start blinking sequence (will auto-launch ball after 1.5s)
      ballBlinking = true;
      blinkStartTime = millis();
      blinkCount = 0;
      xSpeed = 0;
      ySpeed = 0;
      
      // Play blink sound
      if (audioUnlocked && window.soundEnabled && sounds.blink) {
        sounds.blink.cloneNode().play().catch(err => {});
      }
    });
  }

  xBall = gameWidth / 2;
  yBall = gameHeight / 2;
  // Don't randomize direction here - will happen after blink sequence

  dotCompositions.push(new DotComposition(gameWidth/2, gameHeight/2, 3, 10, {r: 255, g: 0, b: 0}))
  dotCompositions.push(new DotComposition(gameWidth * 1.5/8, gameHeight * 1.5/8, 9, 4, {r: 0, g: 0, b: 255}))
  dotCompositions.push(new DotComposition(gameWidth * 6.5/8, gameHeight * 1.5/8, 9, 4, {r: 0, g: 0, b: 255}))
  dotCompositions.push(new DotComposition(gameWidth * 1.5/8, gameHeight * 6.5/8, 9, 4, {r: 0, g: 0, b: 255}))
  dotCompositions.push(new DotComposition(gameWidth * 6.5/8, gameHeight * 6.5/8, 9, 4, {r: 0, g: 0, b: 255}))

  for (const dotComposition of dotCompositions) {
    dotComposition.initialize()
  }

  x1 = x2 = x3 = x4 = gameWidth / 2;
  y1 = y2 = y3 = y4 = gameHeight / 2;

  x1b = x3b = gameWidth / 2;
  y1b = y3b = gameHeight / 4;
  x2b = x4b = gameWidth / 2;
  y2b = y4b = gameHeight / 2;

  x1c = x3c = gameWidth / 2;
  y1c = y3c = gameHeight - gameHeight / 4;
  x2c = x4c = gameWidth / 2;
  y2c = y4c = gameHeight / 2;

  x10 = x30 = gameWidth / 4;
  y10 = y30 = gameHeight / 4;
  x20 = gameWidth / 2;
  y20 = gameHeight / 2;
  x40 = gameWidth / 2;
  y40 = gameHeight / 2;

  x100 = x300 = gameWidth - gameWidth / 4;
  y100 = y300 = gameHeight - gameHeight / 4;
  x200 = gameWidth / 2;
  y200 = gameHeight / 2;
  x400 = gameWidth / 2;
  y400 = gameHeight / 2;

  x1000 = x3000 = gameWidth - gameWidth / 4;
  y1000 = y3000 = gameHeight / 4;
  x2000 = gameWidth / 2;
  y2000 = gameHeight / 2;
  x4000 = gameWidth / 2;
  y4000 = gameHeight / 2;

  x10000 = x30000 = gameWidth / 4;
  y10000 = y30000 = gameHeight - gameHeight / 4;
  x20000 = gameWidth / 2;
  y20000 = gameHeight / 2;
  x40000 = gameWidth / 2;
  y40000 = gameHeight / 2;
}

function mousePressed() {
  // Unlock audio on first click
  if (!audioUnlocked) {
    audioUnlocked = true;
    console.log('Audio unlocked!');
    // Play a silent sound to unlock audio context
    Object.values(sounds).forEach(category => {
      if (category[0]) {
        category[0].play().then(() => {
          category[0].pause();
          category[0].currentTime = 0;
        }).catch(err => {});
      }
    });
  }
  
  // Don't allow shooting until game has actually started
  if (!window.gameStarted) {
    return;
  }
  
  // Fire shot if available
  if (shotsAvailable > 0) {
    if (specialPrimeActive) {
      // TRIPLE SHOT: 1 upward, 2 at 45° angles (left and right)
      // Calculate 45° diagonal speed components
      let diagonalSpeed = 15 / Math.sqrt(2); // Same total speed as straight shot
      
      // Center shot: straight up
      let shotCenter = new ShotBall(mouseX, height - 90, 0, -15);
      shotBalls.push(shotCenter);
      
      // Left shot: 45° up-left
      let shotLeft = new ShotBall(mouseX, height - 90, -diagonalSpeed, -diagonalSpeed);
      shotBalls.push(shotLeft);
      
      // Right shot: 45° up-right
      let shotRight = new ShotBall(mouseX, height - 90, diagonalSpeed, -diagonalSpeed);
      shotBalls.push(shotRight);
      
      shotsAvailable--;  // Only use 1 shot for all 3 balls
    } else {
      // SINGLE SHOT: straight up
      let shot = new ShotBall(mouseX, height - 90);
      shotBalls.push(shot);
      shotsAvailable--;
    }
    
    // Play shoot sound
    if (audioUnlocked && window.soundEnabled && sounds.shoot) {
      sounds.shoot.cloneNode().play().catch(err => {});
    }
    
    // Update display
    document.getElementById('shotsValue').textContent = shotsAvailable;
  }
}

function draw() {
  background(20, 22, 40, 90);
  fill(148, 220, 30);
  noStroke();
  
  // Don't run game logic until player clicks start
  if (!window.gameStarted) {
    return;
  }

  for (const dotComposition of dotCompositions) {
    dotComposition.update()
    dotComposition.display()
  }
  
  // UFO Autopilot AI
  if (autoPilotActive && !ballBlinking) {
    // Track ball position
    autoPilotTargetX = xBall;
    
    // Smooth movement toward ball
    let currentMouseX = mouseX;
    let diff = autoPilotTargetX - currentMouseX;
    
    // Move toward ball position (simulate mouse movement)
    if (abs(diff) > 5) {
      // Override mouseX for autopilot
      mouseX = currentMouseX + diff * 0.15;
    }
    
    // Auto-shoot when ball is above UFO and shots available
    if (yBall > height - 200 && shotsAvailable > 0) {
      if (millis() - autoPilotShootTimer > 1000) { // Shoot every 1 second max
        autoPilotShootTimer = millis();
        
        // Trigger shot programmatically
        if (specialPrimeActive) {
          // TRIPLE SHOT
          let diagonalSpeed = 15 / Math.sqrt(2);
          shotBalls.push(new ShotBall(mouseX, height - 90, 0, -15));
          shotBalls.push(new ShotBall(mouseX, height - 90, -diagonalSpeed, -diagonalSpeed));
          shotBalls.push(new ShotBall(mouseX, height - 90, diagonalSpeed, -diagonalSpeed));
          shotsAvailable--;
        } else {
          // SINGLE SHOT
          shotBalls.push(new ShotBall(mouseX, height - 90));
          shotsAvailable--;
        }
        
        // Play shoot sound
        if (audioUnlocked && window.soundEnabled && sounds.shoot) {
          sounds.shoot.cloneNode().play().catch(err => {});
        }
        
        // Update display
        document.getElementById('shotsValue').textContent = shotsAvailable;
      }
    }
  }
  
  // Handle ball blinking sequence
  if (ballBlinking) {
    let elapsed = millis() - blinkStartTime;
    
    // After 1.5 seconds (3 blinks complete), resume game
    if (elapsed >= 1500) {
      ballBlinking = false;
      randomizeBallDirection();
    }
    // Don't move ball while blinking
  } else {
    move();
  }
  
  display();
  bounce();

  // Update and display shot balls
  for (let i = shotBalls.length - 1; i >= 0; i--) {
    let shot = shotBalls[i];
    if (!shot.update()) {
      shotBalls.splice(i, 1);  // Remove expired shots
    } else {
      shot.display();
    }
  }
  
  // Spawn obstacles on prime numbers in 20s range (23, 29, 43, 47, 61, 67, 83, 89, 101, 103, 107, 109, etc.)
  let currentSecond = Math.floor(millis() / 1000);
  
  // Update counter display
  let counterDisplay = document.getElementById('counterDisplay');
  counterDisplay.textContent = currentSecond;
  
  // Change color to yellow if current second is prime
  if (isPrime(currentSecond)) {
    counterDisplay.classList.add('prime');
  } else {
    counterDisplay.classList.remove('prime');
  }
  
  // Check if we've hit a new prime second in the 20s range
  if (currentSecond !== lastObstacleCheck && isPrimeIn20sRange(currentSecond)) {
    lastObstacleCheck = currentSecond;
    
    // Randomly spawn 1-7 obstacles
    let numObstacles = floor(random(1, 8));  // 1, 2, 3, 4, 5, 6, or 7
    
    for (let i = 0; i < numObstacles; i++) {
      let side = random() < 0.5 ? 'left' : 'right';
      let x, y;
      
      if (side === 'left') {
        // Left side: between 1/8 and 3/8 of width
        x = random(gameWidth * 1/8, gameWidth * 3/8);
      } else {
        // Right side: between 5/8 and 7/8 of width  
        x = random(gameWidth * 5/8, gameWidth * 7/8);
      }
      
      // Random Y position (avoid top and bottom 20%)
      y = random(gameHeight * 0.2, gameHeight * 0.8);
      
      obstacles.push(new Obstacle(x, y, side));
    }
  }
  
  // Update and display obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    let obstacle = obstacles[i];
    if (!obstacle.update()) {
      obstacles.splice(i, 1);  // Remove expired
    } else {
      obstacle.display();
      
      // Check collision with game ball
      if (obstacle.checkBallCollision(xBall, yBall, 12)) {
        // Bounce ball off obstacle
        let angle = atan2(yBall - obstacle.y, xBall - obstacle.x);
        let speed = sqrt(xSpeed * xSpeed + ySpeed * ySpeed);
        xSpeed = cos(angle) * speed;
        ySpeed = sin(angle) * speed;
      }
      
      // Check collision with shot balls
      for (let shot of shotBalls) {
        obstacle.checkShotBallCollision(shot);
      }
    }
  }

  function move() {
    // Increase speed multiplier gradually over time
    speedMultiplier += speedIncreaseRate;
    
    // Apply speed multiplier to ball movement
    xBall += (xSpeed * speedMultiplier) / 2;
    yBall += (ySpeed * speedMultiplier) / 2;
  }

  function bounce() {
    // === PADDLE COLLISIONS (check these FIRST) ===
    
    // UFO PLAYER paddle collision (bottom)
    let ufoLeft = mouseX - 76;
    let ufoRight = mouseX + 76;
    let ufoTop = height - 98;
    let ufoBottom = height - 62;
    
    if (xBall >= ufoLeft && xBall <= ufoRight && yBall + 12 >= ufoTop && yBall <= ufoBottom) {
      // Increment hit count
      paddleHitCounts.ufo++;
      
      // Check if hit count is prime - advance strength
      if (isPrime(paddleHitCounts.ufo)) {
        paddleCurrentStrength.ufo = (paddleCurrentStrength.ufo + 1) % paddleStrengthLevels.length;
      }
      
      // Apply strength multiplier
      let strengthMultiplier = paddleStrengthLevels[paddleCurrentStrength.ufo];
      ySpeed *= -strengthMultiplier;
      xSpeed *= strengthMultiplier;
      
      yBall = ufoTop - 12;
      playRandomSound('ufo');  // Play fx_1_07 or fx_1_08
    }
    
    // PLAYER OBEN paddle collision (top)
    // Dynamic width based on ball's horizontal position
    // Use frozen position if paddle is frozen
    let topPaddleX = (frozenPaddles.top > millis()) ? frozenPositions.top : xBall;
    let topPaddleDynamicWidth = Math.max(60, Math.abs(topPaddleX - gameWidth/2) * 0.3 + 40);
    let topPaddleLeft = topPaddleX - topPaddleDynamicWidth/2;
    let topPaddleRight = topPaddleX + topPaddleDynamicWidth/2;
    let topPaddleTop = 58 - paddleHeight11/2;
    let topPaddleBottom = 58 + paddleHeight11/2;
    
    if (yBall - 12 <= topPaddleBottom && yBall >= topPaddleTop && 
        xBall >= topPaddleLeft && xBall <= topPaddleRight) {
      // Increment hit count
      paddleHitCounts.top++;
      
      // Check if hit count is prime - advance strength
      if (isPrime(paddleHitCounts.top)) {
        paddleCurrentStrength.top = (paddleCurrentStrength.top + 1) % paddleStrengthLevels.length;
      }
      
      // Apply strength multiplier
      let strengthMultiplier = paddleStrengthLevels[paddleCurrentStrength.top];
      ySpeed *= -strengthMultiplier;
      xSpeed *= strengthMultiplier;
      
      yBall = topPaddleBottom + 12;
      playRandomSound('top');  // Play fx_1_03 or fx_1_04
    }
    
    // PLAYER LEFT paddle collision (red paddle on left side)
    // Paddle drawn at: rect(paddleHeight22, yBall / 0.9, paddleWidth22, yBall - 222, 15)
    // Position: x = paddleHeight22 (58), y = yBall/0.9, width = 30, height = yBall-222
    // Use frozen position if paddle is frozen
    let leftPaddleYBall = (frozenPaddles.left > millis()) ? frozenPositions.left : yBall;
    let leftPaddleX = paddleHeight22;  // 58
    let leftPaddleY = leftPaddleYBall / 0.9;
    let leftPaddleWidth = paddleWidth22;  // 30
    let leftPaddleHeight = Math.abs(leftPaddleYBall - 222);
    
    // Using rectMode CENTER
    let leftPaddleLeft = leftPaddleX - leftPaddleWidth/2;
    let leftPaddleRight = leftPaddleX + leftPaddleWidth/2;
    let leftPaddleTop = leftPaddleY - leftPaddleHeight/2;
    let leftPaddleBottom = leftPaddleY + leftPaddleHeight/2;
    
    if (xBall - 12 <= leftPaddleRight && xBall >= leftPaddleLeft &&
        yBall >= leftPaddleTop && yBall <= leftPaddleBottom) {
      // Increment hit count
      paddleHitCounts.left++;
      
      // Check if hit count is prime - advance strength
      if (isPrime(paddleHitCounts.left)) {
        paddleCurrentStrength.left = (paddleCurrentStrength.left + 1) % paddleStrengthLevels.length;
      }
      
      // Apply strength multiplier
      let strengthMultiplier = paddleStrengthLevels[paddleCurrentStrength.left];
      xSpeed *= -strengthMultiplier;
      ySpeed *= strengthMultiplier;
      
      xBall = leftPaddleRight + 12;
      playRandomSound('left');  // Play fx_1_01 or fx_1_02
    }
    
    // PLAYER RIGHT paddle collision (blue paddle on right side)
    // Paddle drawn at: rect(gameWidth - 88, yBall / 0.9, 30, yBall - 222, 15)
    // Use frozen position if paddle is frozen
    let rightPaddleYBall = (frozenPaddles.right > millis()) ? frozenPositions.right : yBall;
    let rightPaddleX = gameWidth - 88;
    let rightPaddleY = rightPaddleYBall / 0.9;
    let rightPaddleWidth = 30;
    let rightPaddleHeight = Math.abs(rightPaddleYBall - 222);
    
    // Using rectMode CENTER
    let rightPaddleLeft = rightPaddleX - rightPaddleWidth/2;
    let rightPaddleRight = rightPaddleX + rightPaddleWidth/2;
    let rightPaddleTop = rightPaddleY - rightPaddleHeight/2;
    let rightPaddleBottom = rightPaddleY + rightPaddleHeight/2;
    
    if (xBall + 12 >= rightPaddleLeft && xBall <= rightPaddleRight &&
        yBall >= rightPaddleTop && yBall <= rightPaddleBottom) {
      // Increment hit count
      paddleHitCounts.right++;
      
      // Check if hit count is prime - advance strength
      if (isPrime(paddleHitCounts.right)) {
        paddleCurrentStrength.right = (paddleCurrentStrength.right + 1) % paddleStrengthLevels.length;
      }
      
      // Apply strength multiplier
      let strengthMultiplier = paddleStrengthLevels[paddleCurrentStrength.right];
      xSpeed *= -strengthMultiplier;
      ySpeed *= strengthMultiplier;
      
      xBall = rightPaddleLeft - 12;
      playRandomSound('right');  // Play fx_1_05 or fx_1_06
    }
    
    // === WALL COLLISIONS (only if ball missed paddle) ===
    
    // Left wall hit - PLAYER RIGHT scores
    if (xBall < 0) {
      xSpeed *= -1;
      xBall = 0;
      score[3]++;
      updateScore();
      playRandomSound('left');  // Play fx_1_01 or fx_1_02
    }
    
    // Right wall hit - PLAYER LEFT scores
    if (xBall > gameWidth) {
      xSpeed *= -1;
      xBall = gameWidth;
      score[2]++;
      updateScore();
      playRandomSound('right');  // Play fx_1_05 or fx_1_06
    }
    
    // Top wall hit - UFO PLAYER scores (ball went PAST top paddle)
    if (yBall < 0) {
      ySpeed *= -1;
      yBall = 0;
      score[0]++;
      updateScore();
      playRandomSound('top');  // Play fx_1_03 or fx_1_04
    }
    
    // Bottom wall hit - PLAYER OBEN scores (UFO player lost!)
    if (yBall > gameHeight) {
      score[1]++;
      updateScore();
      xBall = gameWidth / 2;
      yBall = gameHeight / 2;
      
      // Start blinking sequence
      ballBlinking = true;
      blinkStartTime = millis();
      blinkCount = 0;
      xSpeed = 0;
      ySpeed = 0;
      
      // Play blink sound
      if (audioUnlocked && window.soundEnabled && sounds.blink) {
        sounds.blink.cloneNode().play().catch(err => {});
      }
    }

  push();
  rectMode(CENTER);
  
  // Calculate glow based on strength level
  let ufoStrength = paddleStrengthLevels[paddleCurrentStrength.ufo];
  let ufoGlow = map(ufoStrength, 1.0, 1.1, -10, 12);
  let ufoAlpha = map(ufoStrength, 1.0, 1.1, 222, 255);
  
  drawingContext.shadowOffsetX = 0;
  drawingContext.shadowOffsetY = 4;
  drawingContext.shadowBlur = ufoGlow;
  drawingContext.shadowColor = "white";
  stroke(22, 3, 3, ufoAlpha);
  strokeWeight(4);
  fill(random(255), 0, random(255));

  rect(mouseX, height - 80, 150, 6, 1);
  rect(mouseX, height - 80, paddleWidth1, paddleHeight1, 18);
  fill(random(145), random(25), random(255));
  rect(mouseX, height - 93, 22, 18, 9);
  fill(0, random(255), random(55));
  rect(mouseX - 56, height - 98, 12, 10, 6);
  rect(mouseX + 56, height - 98, 12, 10, 6);
  rect(mouseX - 76, height - 80, 14, 14, 7);
  rect(mouseX + 76, height - 80, 14, 14, 7);
  rect(mouseX, height - 62, 34, 8, 4);
  rect(mouseX -25, height - 62, 8, 8, 4);
  rect(mouseX -38, height - 62, 6, 6, 3);
  rect(mouseX + 25, height - 62, 8, 8, 4);
  rect(mouseX + 38, height - 62, 6, 6, 3);
  pop();

  push();
  blendMode(HARD_LIGHT);
  
  // Calculate glow based on strength level
  let topStrength = paddleStrengthLevels[paddleCurrentStrength.top];
  let topGlow = map(topStrength, 1.0, 1.1, 1, 8);
  
  drawingContext.shadowOffsetX = 0;
  drawingContext.shadowOffsetY = -3;
  drawingContext.shadowBlur = topGlow;
  drawingContext.shadowColor = "white";
  // Blinking effect when frozen
  let topAlpha = 255;
  if (frozenPaddles.top > millis()) {
    // Blink between 5% and 100% opacity (13 to 255)
    topAlpha = map(sin(millis() * 0.01), -1, 1, 13, 255);
  }
  fill(random(44), 190, random(222), topAlpha);
  // Dynamic width: shrinks when ball moves horizontally (like other paddles)
  // Use frozen position if paddle is frozen
  let drawTopPaddleX = (frozenPaddles.top > millis()) ? frozenPositions.top : xBall;
  rect(drawTopPaddleX, 58, Math.max(60, Math.abs(drawTopPaddleX - gameWidth/2) * 0.3 + 40), paddleHeight11, 15);
  pop();

  push();
  blendMode(HARD_LIGHT);
  fill(26, 230, 237, 75);
  rect(xBall, 55, yBall - 222, 36, 98);
  pop();

  push();
  blendMode(OVERLAY);
  drawingContext.shadowOffsetX = 13;
  drawingContext.shadowOffsetY = 2;
  drawingContext.shadowBlur = 1;
  drawingContext.shadowColor = "white";
  fill(25, 205, 255, 255);
  rect(yBall / 1.2, 68, xBall / 2, 10, 5);
  pop();

  push();
  blendMode(SOFT_LIGHT);
  
  // Calculate glow based on strength level
  let leftStrength = paddleStrengthLevels[paddleCurrentStrength.left];
  let leftGlow = map(leftStrength, 1.0, 1.1, 1, 6);
  
  drawingContext.shadowOffsetX = 3;
  drawingContext.shadowOffsetY = 0;
  drawingContext.shadowBlur = leftGlow;
  drawingContext.shadowColor = "white";
  // Blinking effect when frozen
  let leftAlpha = 255;
  if (frozenPaddles.left > millis()) {
    // Blink between 5% and 100% opacity (13 to 255)
    leftAlpha = map(sin(millis() * 0.01), -1, 1, 13, 255);
  }
  fill(200, 0, 60, leftAlpha);
  // Use frozen position if paddle is frozen
  let drawLeftPaddleYBall = (frozenPaddles.left > millis()) ? frozenPositions.left : yBall;
  rect(paddleHeight22, drawLeftPaddleYBall / 0.9, paddleWidth22, drawLeftPaddleYBall - 222, 15);
  pop();

  push();
  blendMode(SOFT_LIGHT);
  fill(200, 200, 100, 200);
  rect(68, yBall / 1.2, 10, yBall - 200, 5);
  pop();

  push();
  blendMode(OVERLAY);
  fill(200, 200, 100, 200);
  rect(63, yBall / 1.3, 20, yBall - 100, 10);
  pop();

  push();
  blendMode(HARD_LIGHT);
  
  // Calculate glow based on strength level
  let rightStrength = paddleStrengthLevels[paddleCurrentStrength.right];
  let rightGlow = map(rightStrength, 1.0, 1.1, 1, 8);
  
  drawingContext.shadowOffsetX = 5;
  drawingContext.shadowOffsetY = 0;
  drawingContext.shadowBlur = rightGlow;
  drawingContext.shadowColor = "blue";
  // Blinking effect when frozen
  let rightAlpha = 255;
  if (frozenPaddles.right > millis()) {
    // Blink between 5% and 100% opacity (13 to 255)
    rightAlpha = map(sin(millis() * 0.01), -1, 1, 13, 255);
  }
  fill(130, 190, 200, rightAlpha);
  // Use frozen position if paddle is frozen
  let drawRightPaddleYBall = (frozenPaddles.right > millis()) ? frozenPositions.right : yBall;
  rect(gameWidth - 88, drawRightPaddleYBall / 0.9, 30, drawRightPaddleYBall - 222, 15);
  pop();

  push();
  blendMode(SOFT_LIGHT);
  fill(162, 120, 190, 250);
  rect(gameWidth - 78, yBall / 1.8, 10, yBall - 160, 5);
  pop();

  push();
  blendMode(OVERLAY);
  fill(130, 127, 214, 230);
  rect(gameWidth - 83, xBall / 1.3, 20, yBall - 100, 15);
  pop();

  paddle();
  
  // === LAUFLICHTER COLLISIONS (make game unpredictable!) ===
  // Check collision with all moving dots (3px radius each)
  let dotRadius = 1.5;  // Half of 3px diameter
  let ballRadius = 12;
  let collisionDistance = dotRadius + ballRadius;
  
  // Helper function to check dot collision
  function checkDotCollision(dotX, dotY) {
    let dx = xBall - dotX;
    let dy = yBall - dotY;
    let distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < collisionDistance) {
      // Calculate bounce angle based on collision position
      let angle = Math.atan2(dy, dx);
      let speed = Math.sqrt(xSpeed * xSpeed + ySpeed * ySpeed);
      xSpeed = Math.cos(angle) * speed;
      ySpeed = Math.sin(angle) * speed;
      
      // Play random LAUFLICHTER collision sound
      playRandomSound('lauflichter');
      
      return true;
    }
    return false;
  }
  
  // Check all DotComposition dots (red and blue)
  for (const dotComposition of dotCompositions) {
    for (const dot of dotComposition.dots) {
      let dotCollisionRadius = dotComposition.dotSize / 2;
      let dotBallDistance = dotCollisionRadius + ballRadius;
      let dx = xBall - dot.position.x;
      let dy = yBall - dot.position.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < dotBallDistance) {
        // Calculate bounce angle based on collision position
        let angle = Math.atan2(dy, dx);
        let speed = Math.sqrt(xSpeed * xSpeed + ySpeed * ySpeed);
        xSpeed = Math.cos(angle) * speed;
        ySpeed = Math.sin(angle) * speed;
        
        // Play random LAUFLICHTER collision sound
        playRandomSound('lauflichter');
        break;
      }
    }
  }
  
  // Check all LAUFLICHTER groups (24 dots total)
  checkDotCollision(x1b, y1b) || checkDotCollision(x2b, y2b) || 
  checkDotCollision(x3b, y3b) || checkDotCollision(x4b, y4b) ||
  checkDotCollision(x1c, y1c) || checkDotCollision(x2c, y2c) || 
  checkDotCollision(x3c, y3c) || checkDotCollision(x4c, y4c) ||
  checkDotCollision(x10, y10) || checkDotCollision(x20, y20) || 
  checkDotCollision(x30, y30) || checkDotCollision(x40, y40) ||
  checkDotCollision(x100, y100) || checkDotCollision(x200, y200) || 
  checkDotCollision(x300, y300) || checkDotCollision(x400, y400) ||
  checkDotCollision(x1000, y1000) || checkDotCollision(x2000, y2000) || 
  checkDotCollision(x3000, y3000) || checkDotCollision(x4000, y4000) ||
  checkDotCollision(x10000, y10000) || checkDotCollision(x20000, y20000) || 
  checkDotCollision(x30000, y30000) || checkDotCollision(x40000, y40000);
  }
}

function updateScore() {
  // Update each player's score in their respective colored span
  let scoreContainer = document.getElementById('scoreText');
  if (scoreContainer) {
    let spans = scoreContainer.querySelectorAll('span');
    spans[0].textContent = score[0];  // UFO (pink)
    spans[2].textContent = score[1];  // OBEN (green-blue)
    spans[4].textContent = score[2];  // LEFT (deep pink)
    spans[6].textContent = score[3];  // RIGHT (light blue)
  }
  
  // Check for prime number after score update
  checkPrimeAndUpdateShots();
}

function display() {
  push();
  blendMode(HARD_LIGHT);
  drawingContext.shadowOffsetX = 2;
  drawingContext.shadowOffsetY = 2;
  drawingContext.shadowBlur = 19;
  drawingContext.shadowColor = "hotpink";
  fill(200, 210, 100);
  stroke(200, 200, 220);
  strokeWeight(3);
  
  // Calculate ball alpha based on blinking state
  let ballAlpha = 255;
  if (ballBlinking) {
    let elapsed = millis() - blinkStartTime;
    let blinkPhase = (elapsed % 500) / 500; // 0 to 1 over 0.5 seconds
    
    // At 0s, 0.5s, 1s, 1.5s → alpha = 255 (100% pink)
    // In between → alpha = 0 (0% transparent)
    if (blinkPhase < 0.5) {
      // First half: fade from 100% to 0%
      ballAlpha = map(blinkPhase, 0, 0.5, 255, 0);
    } else {
      // Second half: fade from 0% to 100%
      ballAlpha = map(blinkPhase, 0.5, 1.0, 0, 255);
    }
  }
  
  fill(230, 50, 150, ballAlpha);
  ellipse(xBall, yBall, 24, 24);
  pop();

  push();
  blendMode(SOFT_LIGHT);
  fill(200, 150, 150);
  stroke(190, 100, 180, 200);
  strokeWeight(random(0, 16));

  ellipse(x1b, y1b, 3, 3);
  y1b -= 3;
  if (y1b < 0) y1b = gameHeight;

  ellipse(x2b, y2b, 3, 3);
  x2b -= 3;
  if (x2b < 0) x2b = gameWidth;

  ellipse(x3b, y3b, 3, 3);
  y3b += 3;
  if (y3b > gameHeight) y3b = 0;

  ellipse(x4b, y4b, 3, 3);
  x4b += 3;
  if (x4b > gameWidth) x4b = 0;
  pop();

  push();
  blendMode(SOFT_LIGHT);
  fill(200, 150, 150);
  stroke(190, 100, 180, 200);
  strokeWeight(random(0, 16));

  ellipse(x1c, y1c, 3, 3);
  y1c -= 3;
  if (y1c < 0) y1c = gameHeight;

  ellipse(x2c, y2c, 3, 3);
  x2c -= 3;
  if (x2c < 0) x2c = gameWidth;

  ellipse(x3c, y3c, 3, 3);
  y3c += 3;
  if (y3c > gameHeight) y3c = 0;

  ellipse(x4c, y4c, 3, 3);
  x4c += 3;
  if (x4c > gameWidth) x4c = 0;
  pop();

  push();
  blendMode(HARD_LIGHT);
  fill(200, 150, 150, 255);
  stroke(180, 50, 150, 50);
  strokeWeight(random(0, 16));

  ellipse(x10, y10, 3, 3);
  y10 -= 3;
  if (y10 < 0) y10 = gameHeight;

  ellipse(x20, y20, 3, 3);
  x20 -= 3;
  if (x20 < 0) x20 = gameWidth;

  ellipse(x30, y30, 3, 3);
  y30 += 3;
  if (y30 > gameHeight) y30 = 0;

  ellipse(x40, y40, 3, 3);
  x40 += 2;
  if (x40 > gameWidth) x40 = 0;
  pop();

  push();
  blendMode(HARD_LIGHT);
  fill(200, 150, 150, 255);
  stroke(180, 80, 190, 120);
  strokeWeight(random(0, 16));

  ellipse(x100, y100, 3, 3);
  y100 -= 3;
  if (y100 < 0) y100 = gameHeight;

  ellipse(x200, y200, 3, 3);
  x200 -= 3;
  if (x200 < 0) x200 = gameWidth;

  ellipse(x300, y300, 3, 3);
  y300 += 3;
  if (y300 > gameHeight) y300 = 0;

  ellipse(x400, y400, 3, 3);
  x400 += 3;
  if (x400 > gameWidth) x400 = 0;
  pop();

  push();
  blendMode(HARD_LIGHT);
  fill(200, 150, 150, 255);
  stroke(130, 80, 210, 120);
  strokeWeight(random(0, 16));

  ellipse(x1000, y1000, 3, 3);
  y1000 -= 3;
  if (y1000 < 0) y1000 = gameHeight;

  ellipse(x2000, y2000, 3, 3);
  x2000 -= 3;
  if (x2000 < 0) x2000 = gameWidth;

  ellipse(x3000, y3000, 3, 3);
  y3000 += 3;
  if (y3000 > gameHeight) y3000 = 0;

  ellipse(x4000, y4000, 3, 3);
  x4000 += 3;
  if (x4000 > gameWidth) x4000 = 0;
  pop();

  push();
  blendMode(HARD_LIGHT);
  fill(200, 150, 150, 255);
  stroke(130, 190, 190, 30);
  strokeWeight(random(0, 16));

  ellipse(x10000, y10000, 3, 3);
  y10000 -= 3;
  if (y10000 < 0) y10000 = gameHeight;

  ellipse(x20000, y20000, 3, 3);
  x20000 -= 3;
  if (x20000 < 0) x20000 = gameWidth;

  ellipse(x30000, y30000, 3, 3);
  y30000 += 3;
  if (y30000 > gameHeight) y30000 = 0;

  ellipse(x40000, y40000, 3, 3);
  x40000 += 3;
  if (x40000 > gameWidth) x40000 = 0;
  pop();

  fill(180, 50, 150);
  rect(0, gameHeight / 2, gameWidth, 0.5);
  rect(gameWidth / 2, 0, 0.5, gameHeight);
  rect(0, gameHeight / 4, gameWidth, 0.1);
  rect(gameWidth / 4, 0, 0.1, gameHeight);
  rect(0, gameHeight - gameHeight / 4, gameWidth, 0.1);
  rect(gameWidth - gameWidth / 4, 0, 0.1, gameHeight);
}

function paddle() {
  if (xBall > mouseX && xBall < mouseX + 20 && yBall + 80 >= 1000) {
    xSpeed *= -1;
    ySpeed *= -1;
  }

  push();
  blendMode(HARD_LIGHT);
  fill(200, 150, 150, 255);
  stroke(130, 190, 190, 30);
  strokeWeight(random(0, 16));

  ellipse(x10000, y10000, 3, 3);
  y10000 -= 4;
  if (y10000 < 0) y10000 = gameHeight;

  ellipse(x20000, y20000, 3, 3);
  x20000 -= 4;
  if (x20000 < 0) x20000 = gameWidth;

  ellipse(x30000, y30000, 3, 3);
  y30000 += 4;
  if (y30000 > gameHeight) y30000 = 0;

  ellipse(x40000, y40000, 3, 3);
  x40000 += 4;
  if (x40000 > gameWidth) x40000 = 0;
  pop();
}

function windowResized() {
  let container = document.getElementById('gameContainer');
  let w = container.offsetWidth;
  let h = container.offsetHeight;
  resizeCanvas(w, h);
  gameWidth = w;
  gameHeight = h;
}
    </script>
    </div> <!-- End mainWrapper -->
    
    <!-- Service Worker registration -->
    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("./sw.js");
        });
      }
    </script>

  </body>
</html>